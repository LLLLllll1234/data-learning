# Trino 优化器架构与执行流程可视化图解

## 📚 目录
1. [整体优化流程](#1-整体优化流程)
2. [代价模型与决策机制](#2-代价模型与决策机制)  
3. [动态过滤执行时序](#3-动态过滤执行时序)
4. [Join策略选择流程](#4-join策略选择流程)
5. [分布式执行架构](#5-分布式执行架构)
6. [图解总结](#6-图解总结)

---

## 1. 整体优化流程

### 1.1 从SQL到执行的完整流程

以下图表展示了Trino从接收SQL查询到最终执行的完整优化pipeline：

*[优化流程图已在上面显示]*

### 1.2 流程解析

#### 🔍 **解析与分析阶段**
- **Parse**: 将SQL文本解析为抽象语法树(AST)
- **Analyze**: 语义分析、名称解析、类型检查、权限验证

#### 📋 **逻辑计划阶段**
- 将AST转换为关系代数表示
- 生成初始的逻辑执行计划树

#### ⚡ **规则优化阶段 (RBO)**
- **谓词下推**: 将WHERE条件尽可能下推到数据源
- **投影下推**: 只读取查询需要的列
- **Join重排序**: 基于启发式规则调整Join顺序
- **常量折叠**: 预计算常量表达式
- **过滤合并**: 合并可以合并的过滤条件

#### 📊 **统计收集**
- 从连接器获取表和列的统计信息
- 包括行数、NDV、min/max值、数据分布等

#### 💰 **代价优化阶段 (CBO)**
- 基于统计信息进行精确的代价估算
- Join策略选择 (Broadcast vs Partitioned)
- 动态过滤规划
- Exchange策略优化

#### 🏗️ **物理规划**
- 生成可执行的物理计划
- 确定Fragment划分和数据分布策略
- 生成并行执行任务

---

## 2. 代价模型与决策机制

### 2.1 代价模型组成要素

*[代价模型图已在上面显示]*

### 2.2 代价计算详解

#### 💻 **CPU代价**
```
CPU Cost = Σ (Operator Processing Cost)
包括:
- 表达式计算 (过滤、投影)
- 哈希表构建 (Join、Aggregation)  
- 哈希探测 (Join Probe)
- 排序操作 (ORDER BY, Window Functions)
```

#### 💾 **内存代价**
```
Memory Cost = Peak Memory Requirement  
包括:
- Join哈希表大小
- 排序缓冲区
- 聚合状态存储
- 窗口函数缓冲区
```

#### 🌐 **网络代价**
```
Network Cost = Data Transmission Volume
包括:  
- 表数据重分区 (Hash Exchange)
- 小表广播 (Broadcast Exchange)
- 中间结果传输 (Fragment间通信)
```

#### 💿 **IO代价**  
```
IO Cost = Data Reading Volume
包括:
- 表扫描成本
- 文件系统访问
- 分区读取
- 列式数据解码
```

### 2.3 优化决策示例

#### Join策略选择
```
if (Right Table Size < Broadcast Threshold) {
    BroadcastCost = NetworkCost + MemoryCost  
    PartitionedCost = RepartitionCost + LocalJoinCost
    
    选择cost更低的策略
} else {
    强制使用 Partitioned Join
}
```

---

## 3. 动态过滤执行时序

### 3.1 动态过滤执行流程

*[动态过滤时序图已在上面显示]*

### 3.2 关键时间点分析

#### ⏱️ **T=0ms: 执行开始**
- Coordinator同时启动Build侧和Probe侧Fragment
- Build侧开始扫描小表并应用静态过滤
- Probe侧开始扫描大表，但尚未获得动态过滤

#### ⏱️ **T=500ms: 动态过滤生成**
- Build侧完成Join操作，收集到Join key的值域
- 生成动态过滤器 (BloomFilter / In-List / Min-Max)  
- 将过滤器推送给Probe侧

#### ⏱️ **T=500-2000ms: 过滤器应用**
- Probe侧接收并应用动态过滤器
- 大量不匹配的数据被过滤掉 (通常90%+)
- 显著减少后续Join和聚合的数据量

### 3.3 性能提升效果

| 指标 | 无动态过滤 | 有动态过滤 | 提升 |
|-----|-----------|-----------|------|
| 扫描行数 | 6亿行 | 2300万行 | 96%↓ |
| IO量 | 24GB | 920MB | 96%↓ |  
| 网络传输 | 24GB | 920MB | 96%↓ |
| 执行时间 | 45秒 | 2.1秒 | 20x↑ |

---

## 4. Join策略选择流程

### 4.1 Join策略决策树

*[Join策略选择图已在上面显示]*

### 4.2 策略对比分析

#### 🌐 **Broadcast Join**
**适用场景:**
- 右表较小 (< broadcast_threshold)
- 星型模式查询 (维表Join事实表)
- 左表已经合理分区

**优势:**
- 无需重分区左表，节省网络开销
- Join处理速度快 (本地哈希Join)
- 适合OLAP分析查询

**劣势:**  
- 每个节点需存储完整右表副本
- 内存使用量高
- 不适合大表Join大表

#### 🔄 **Partitioned Join**
**适用场景:**
- 两表都很大
- 内存受限环境
- Join key分布较为均匀

**优势:**
- 内存使用分摊到各节点
- 可处理任意大小的表
- 更好的可伸缩性

**劣势:**
- 需要重分区两张表
- 网络开销较大  
- 数据倾斜影响性能

### 4.3 阈值调优建议

```sql
-- 针对不同workload调整阈值
-- OLAP场景：适当提高广播阈值
SET SESSION broadcast_join_threshold = '200MB';

-- ETL场景：降低广播阈值，减少内存压力  
SET SESSION broadcast_join_threshold = '50MB';

-- 自适应场景：让CBO自动选择
SET SESSION join_distribution_type = 'AUTOMATIC';
```

---

## 5. 分布式执行架构

### 5.1 Fragment执行模型

*[分布式执行图已在上面显示]*

### 5.2 执行模型解析

#### 🎯 **Fragment 0 (SINGLE) - 最终汇聚**
- 运行在Coordinator节点
- 负责最终结果聚合和排序
- 单点处理，适合少量结果集

#### ⚡ **Fragment 1 (HASH) - 中间处理**  
- 分布在多个Worker节点
- 按Hash分区并行处理
- 执行Join、部分聚合等计算密集操作

#### 📁 **Fragment 2/3 (SOURCE) - 数据源扫描**
- 直接连接数据源 (表、文件)
- 应用谓词过滤和投影下推
- 并行读取不同的数据分片 (Splits)

### 5.3 数据交换模式

#### 🔀 **Hash Exchange**
- 按指定列的哈希值分发数据
- 保证相同key的数据到达同一节点
- 用于Join和GroupBy操作

#### 📡 **Broadcast Exchange**  
- 将数据广播到所有目标节点
- 适用于小表分发
- 内存开销大但网络效率高

#### 📍 **Single Exchange**
- 将所有数据汇聚到单个节点
- 用于最终结果收集
- ORDER BY和LIMIT的典型场景

---

## 6. 图解总结

### 6.1 优化器核心概念地图

```
Trino优化器 = 规则引擎 + 代价模型 + 统计信息

规则引擎 (RBO):
├── 逻辑变换规则 (谓词下推、投影下推、常量折叠)  
├── 重写规则 (子查询展开、Join重排序)
└── 简化规则 (冗余消除、表达式简化)

代价模型 (CBO):
├── 基础代价 (CPU、内存、网络、IO)
├── 算子代价 (扫描、Join、聚合、排序)  
└── 策略选择 (Join分发、Exchange模式)

统计信息:
├── 表统计 (行数、数据大小)
├── 列统计 (NDV、分布、空值率)
└── 直方图 (详细分布信息)
```

### 6.2 性能优化效果层次

```
Level 1 - 基础优化 (10-50%提升):
├── 谓词下推 → 减少扫描数据量
├── 列裁剪 → 减少IO和网络传输  
└── 分区裁剪 → 跳过不相关分区

Level 2 - 策略优化 (2-10x提升):  
├── Join策略选择 → 广播vs分区
├── Join重排序 → 小表优先
└── 聚合策略 → 部分聚合

Level 3 - 高级优化 (10-100x提升):
├── 动态过滤 → 运行时数据裁剪
├── 统计信息精确化 → CBO决策精准
└── 物理设计优化 → 分区、分桶、预排序
```

### 6.3 调优检查清单

#### ✅ **查询分析**
- [ ] 使用 `EXPLAIN (TYPE DISTRIBUTED)` 查看执行计划
- [ ] 检查行数估算是否合理
- [ ] 确认Join策略选择是否适当
- [ ] 查看是否有昂贵的Sort/Exchange操作

#### ✅ **统计信息**  
- [ ] 定期执行 `ANALYZE TABLE` 更新统计
- [ ] 检查NDV估算是否准确
- [ ] 验证分区统计是否最新

#### ✅ **会话参数**
- [ ] 启用动态过滤: `enable_dynamic_filtering = true`
- [ ] 合理设置广播阈值: `broadcast_join_threshold`  
- [ ] 选择适当的Join策略: `join_distribution_type`

#### ✅ **表设计**
- [ ] 基于查询模式设计分区策略
- [ ] 考虑预排序减少排序开销
- [ ] 使用合适的文件格式 (Parquet/ORC)

---

## 📋 总结

通过这些可视化图表，我们可以清晰地理解：

1. **优化器工作原理**: 从SQL解析到执行的完整pipeline，RBO和CBO的协同工作
2. **代价模型机制**: 多维度代价计算如何指导优化决策
3. **动态过滤威力**: 运行时优化如何带来数量级的性能提升  
4. **Join策略选择**: 广播和分区策略的权衡考虑
5. **分布式执行**: Fragment模型和数据交换的协调机制

这些知识将帮助你：
- **读懂执行计划**，快速定位性能瓶颈
- **理解优化决策**，知道为什么某个策略被选中
- **调优查询性能**，针对性地应用优化技术
- **设计高效模型**，从源头避免性能问题

掌握了这些可视化概念，你就拥有了Trino性能优化的"全景地图"！🗺️✨
